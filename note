# Copyright 2023 The RoboPianist Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""One-handed version of `piano_with_shadow_hands.py`."""

from typing import List, Optional, Sequence, Tuple

import numpy as np
from dm_control.composer import variation as base_variation
from dm_control.composer.observation import observable
from dm_control.utils.rewards import tolerance
from dm_control.utils.inverse_kinematics import qpos_from_site_pose
from dm_env import specs
from mujoco_utils import spec_utils
import mujoco

import robopianist.models.hands.shadow_hand_constants as hand_consts
from robopianist.models.arenas import stage
from robopianist.models.hands import HandSide
from robopianist.music import midi_file
from robopianist.suite import composite_reward
from robopianist.suite.tasks import base

# Distance thresholds for the shaping reward.
_FINGER_CLOSE_ENOUGH_TO_KEY = 0.01
_KEY_CLOSE_ENOUGH_TO_PRESSED = 0.05

# Energy penalty coefficient.
_ENERGY_PENALTY_COEF = 5e-3

# Number of steps for each trajectory segment (e.g., hover towards key, press, return)
_NUM_STEPS_PER_SEGMENT = 10

# Control gains for feedforward-feedback control
_KP = 10.0  # Increased to improve tracking
_KD = 3.0   # Increased for more damping

# Joints for each finger (for IK).
_FINGER_JOINTS = [
    ['rh_THJ5', 'rh_THJ4', 'rh_THJ3', 'rh_THJ2', 'rh_THJ1'],
    ['rh_FFJ4', 'rh_FFJ3', 'rh_FFJ2', 'rh_FFJ1'],
    ['rh_MFJ4', 'rh_MFJ3', 'rh_MFJ2', 'rh_MFJ1'],
    ['rh_RFJ4', 'rh_RFJ3', 'rh_RFJ2', 'rh_RFJ1'],
    ['rh_LFJ4', 'rh_LFJ3', 'rh_LFJ2', 'rh_LFJ1'],
]

_WRIST_JOINTS = ['rh_WRJ2', 'rh_WRJ1']

class PianoWithOneShadowHand(base.PianoTask):
    def __init__(
        self,
        midi: midi_file.MidiFile,
        hand_side: HandSide,
        n_steps_lookahead: int = 1,
        n_seconds_lookahead: Optional[float] = None,
        trim_silence: bool = False,
        wrong_press_termination: bool = False,
        initial_buffer_time: float = 0.0,
        disable_fingering_reward: bool = False,
        disable_colorization: bool = False,
        augmentations: Optional[Sequence[base_variation.Variation]] = None,
        **kwargs,
    ) -> None:
        super().__init__(arena=stage.Stage(), **kwargs)

        if trim_silence:
            midi = midi.trim_silence()
        self._midi = midi
        self._n_steps_lookahead = n_steps_lookahead
        if n_seconds_lookahead is not None:
            self._n_steps_lookahead = int(
                np.ceil(n_seconds_lookahead / self.control_timestep)
            )
        self._initial_buffer_time = initial_buffer_time
        self._disable_fingering_reward = disable_fingering_reward
        self._wrong_press_termination = wrong_press_termination
        self._disable_colorization = disable_colorization
        self._augmentations = augmentations

        self._hand_side = hand_side
        if self._hand_side == HandSide.LEFT:
            self._hand = self._left_hand
            self._right_hand.detach()
            self._finger_joints = [[f"lh_shadow_hand/{j}" for j in joints] for joints in _FINGER_JOINTS]
        else:
            self._hand = self._right_hand
            self._left_hand.detach()
            self._finger_joints = [[f"rh_shadow_hand/{j}" for j in joints] for joints in _FINGER_JOINTS]
        
        self._wrist_joints = _WRIST_JOINTS

        if not disable_fingering_reward and not disable_colorization:
            self._colorize_fingertips()
        self._reset_quantities_at_episode_init()
        self._reset_trajectory(self._midi)
        self._add_observables()
        self._set_rewards()

        # Motion planning state
        self._trajectories = [[] for _ in range(5)]  # One trajectory per finger (now in joint space)
        self._traj_steps = [0 for _ in range(5)]  # Current step in each trajectory
        self._last_qpos = None  # Last qpos for the hand (Joint Positions)
        self._last_qvel = None  # Last qvel for the hand (Joint Velocities)

    def _set_rewards(self) -> None:
        self._reward_fn = composite_reward.CompositeReward(
            key_press_reward=self._compute_key_press_reward,
            sustain_reward=self._compute_sustain_reward,
            energy_reward=self._compute_energy_reward,
        )
        if not self._disable_fingering_reward:
            self._reward_fn.add("finger_movement_reward", self._compute_fingering_reward)

    def _reset_quantities_at_episode_init(self) -> None:
        self._t_idx: int = 0
        self._should_terminate: bool = False
        self._discount: float = 1.0
        self._trajectories = [[] for _ in range(5)]
        self._traj_steps = [0 for _ in range(5)]
        self._last_qpos = None
        self._last_qvel = None

    def _maybe_change_midi(self, random_state) -> None:
        if self._augmentations is not None:
            midi = self._midi
            for var in self._augmentations:
                midi = var(initial_value=midi, random_state=random_state)
            self._reset_trajectory(midi)

    def _reset_trajectory(self, midi: midi_file.MidiFile) -> None:
        note_traj = midi_file.NoteTrajectory.from_midi(midi, self.control_timestep)
        note_traj.add_initial_buffer_time(self._initial_buffer_time)
        self._notes = note_traj.notes
        self._sustains = note_traj.sustains
        print(f"Total timesteps in MIDI: {len(self._notes)}")
        print(f"First few timesteps of notes: {self._notes[:5]}")
        print(f"First few timesteps of sustains: {self._sustains[:5]}")
        for t, notes in enumerate(self._notes):
            if notes:
                print(f"Timestep {t}: {notes}")
        buffer_steps = int(self._initial_buffer_time / self.control_timestep)
        print(f"Initial buffer time: {self._initial_buffer_time} seconds, {buffer_steps} steps")

    def _plan_with_rrt(self, key: int, finger: int, physics) -> List[np.ndarray]:
        """Plan a path for the finger to reach the key using RRT in joint space."""
        # Get current joint configuration (start)
        start_qpos = np.zeros(len(self._finger_joints[finger]))
        for i, joint_name in enumerate(self._finger_joints[finger]):
            joint_idx = physics.model.name2id(joint_name, "joint")
            start_qpos[i] = physics.data.qpos[joint_idx]
        print(f"Finger {finger}: Starting joint positions: {start_qpos}")

        # Perturb initial joint positions to flex the finger
        original_qpos = physics.data.qpos.copy()
        for i, joint_name in enumerate(self._finger_joints[finger]):
            joint_idx = physics.model.name2id(joint_name, "joint")
            joint_range = physics.model.jnt_range[joint_idx]
            # Flex the joint slightly (e.g., 10% of the range toward the lower limit)
            physics.data.qpos[joint_idx] = joint_range[0] + 0.1 * (joint_range[1] - joint_range[0])
        mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

        fingertip_site = self._hand.fingertip_sites[finger]
        fingertip_pos = physics.bind(fingertip_site).xpos.copy()
        fingertip_xmat = physics.bind(fingertip_site).xmat.reshape(3, 3)
        print(f"Finger {finger}: Perturbed fingertip position: {fingertip_pos}")

        # Reset joint positions
        physics.data.qpos[:] = original_qpos
        mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

        # Get target key position in world frame
        key_site = self.piano.keys[key].site[0]
        key_pos = physics.bind(key_site).xpos.copy()
        print(f"Key {key} position: {key_pos}")

        # Print key joint range to determine required press depth
        # key_joint_id = physics.model.name2id(f"key_{key}", "joint")
        # key_range = physics.model.jnt_range[key_joint_id]
        # print(f"Key {key} joint range: {key_range} (unpressed to fully pressed)")

        # Adjust key position for pressing (start with a closer target, e.g., 10 mm below)
        press_pos = key_pos.copy()
        press_pos[-1] -= 0.005  # Start with 10 mm below the key surface
        print(f"Initial target press position: {press_pos}")

        # Convert press_pos to the fingertip's local frame
        relative_pos = press_pos - fingertip_pos
        fingertip_xmat_inv = np.linalg.inv(fingertip_xmat)
        local_press_pos = fingertip_xmat_inv @ relative_pos
        print(f"Finger {finger}: Target position in local frame: {local_press_pos}")

        # Compute goal joint configuration using IK with relaxed parameters
        site_name = self._hand.fingertip_sites[finger].name
        if self._hand_side == HandSide.LEFT:
            full_site_name = f"lh_shadow_hand/{site_name}"
        else:
            full_site_name = f"rh_shadow_hand/{site_name}"


        # help(qpos_from_site_pose)
        ik_result = qpos_from_site_pose(
            physics=physics,
            site_name=full_site_name,
            target_pos=local_press_pos,
            target_quat=None,  # We can add orientation constraints later if needed
            joint_names=self._finger_joints[finger],
            tol=1e-1,  # Relaxed tolerance (was 1e-2)
            max_steps=500,  # Increased iterations (was 200)
            regularization_threshold = 0.01, # Apply regularization sooner
            regularization_strength = 0.1, # Regularization strength
            max_update_norm = 1.0, # Smaller updates for stability
            progress_thresh = 50.0, # Progress threshold for early termination
        )

        # Check IK result
        if ik_result.err_norm > 0.2:  # Further relaxed threshold (was 0.1)
            print(f"Finger {finger}: IK failed to converge, err_norm={ik_result.err_norm}")
            # Fallback: Project toward the goal position
            print(f"Finger {finger}: Falling back to projection toward goal position")
            goal_qpos = self._project_toward_goal(
                physics, finger, start_qpos, fingertip_pos, press_pos
            )
            if goal_qpos is None:
                print(f"Finger {finger}: Projection failed, returning empty trajectory")
                return []
        else:
            print(f"Finger {finger}: IK succeeded, err_norm={ik_result.err_norm}")
            goal_qpos = np.zeros(len(self._finger_joints[finger]))
            for i, joint_name in enumerate(self._finger_joints[finger]):
                joint_idx = physics.model.name2id(joint_name, "joint")
                goal_qpos[i] = ik_result.qpos[joint_idx]

        print(f"Finger {finger}: Goal joint positions: {goal_qpos}")

        # Joint limits
        joint_limits = np.zeros((len(self._finger_joints[finger]), 2))
        for i, joint_name in enumerate(self._finger_joints[finger]):
            joint_idx = physics.model.name2id(joint_name, "joint")
            joint_limits[i] = physics.model.jnt_range[joint_idx]
        print(f"Finger {finger}: Joint limits: {joint_limits}")

        # RRT parameters
        step_size = 0.1
        max_iterations = 1000
        goal_bias = 0.1

        # Initialize the tree with the start configuration
        tree = [(start_qpos, None)]
        path_found = False

        for _ in range(max_iterations):
            if np.random.random() < goal_bias:
                q_rand = goal_qpos
            else:
                q_rand = np.random.uniform(joint_limits[:, 0], joint_limits[:, 1])

            distances = [np.linalg.norm(q - q_rand) for q, _ in tree]
            nearest_idx = np.argmin(distances)
            q_near, _ = tree[nearest_idx]

            direction = q_rand - q_near
            distance = np.linalg.norm(direction)
            if distance < 1e-6:
                continue
            direction = direction / distance
            q_new = q_near + min(step_size, distance) * direction

            q_new = np.clip(q_new, joint_limits[:, 0], joint_limits[:, 1])

            if not self._check_collision(physics, finger, q_new):
                tree.append((q_new, nearest_idx))

                if np.linalg.norm(q_new - goal_qpos) < step_size:
                    path_found = True
                    break

        if not path_found:
            print(f"Finger {finger}: RRT failed to find a path to the goal")
            return []

        path = []
        current_idx = len(tree) - 1
        while current_idx is not None:
            q, parent_idx = tree[current_idx]
            path.append(q)
            current_idx = parent_idx
        path.reverse()

        smoothed_path = []
        num_steps = _NUM_STEPS_PER_SEGMENT * 3
        for i in range(len(path) - 1):
            q_start = path[i]
            q_end = path[i + 1]
            for t in np.linspace(0, 1, num_steps // (len(path) - 1)):
                q = q_start + t * (q_end - q_start)
                smoothed_path.append(q)

        return smoothed_path

    def _project_toward_goal(
        self, physics, finger: int, start_qpos: np.ndarray, fingertip_pos: np.ndarray, target_pos: np.ndarray
    ) -> Optional[np.ndarray]:
        """Project the fingertip toward the target position by moving joints incrementally."""
        current_qpos = start_qpos.copy()
        current_fingertip_pos = fingertip_pos.copy()
        max_projection_steps = 10
        step_size = 0.005 # 5 mm step

        for step in range(max_projection_steps):
            # Compute the direction from current fingertip position to target position
            direction = target_pos - fingertip_pos
            distance = np.linalg.norm(direction)
            if distance < 1e-3:
                print(f"Finger {finger}: Fingertip already at target position")
                return current_qpos

            # Normalize direction and take a small step (e.g., 5 mm)
            direction = direction / distance
            # step_size = 0.005  # 5 mm step
            # intermediate_pos = fingertip_pos + step_size * direction
            intermediate_pos = current_fingertip_pos + step_size * direction
            print(f"Finger {finger}: Projecting to intermediate position: {intermediate_pos}")

            # Convert intermediate position to local frame
            fingertip_site = self._hand.fingertip_sites[finger]
            fingertip_xmat = physics.bind(fingertip_site).xmat.reshape(3, 3)
            fingertip_xmat_inv = np.linalg.inv(fingertip_xmat)
            local_intermediate_pos = fingertip_xmat_inv @ (intermediate_pos - current_fingertip_pos)

            # Try IK again for the intermediate position
            site_name = self._hand.fingertip_sites[finger].name
            if self._hand_side == HandSide.LEFT:
                full_site_name = f"lh_shadow_hand/{site_name}"
            else:
                full_site_name = f"rh_shadow_hand/{site_name}"

            ik_result = qpos_from_site_pose(
                physics=physics,
                site_name=full_site_name,
                target_pos=local_intermediate_pos,
                target_quat=None,
                joint_names=self._finger_joints[finger],
                tol=1e-1,
                max_steps=1000,
                regularization_threshold = 0.01,
                regularization_strength = 0.1,
                max_update_norm = 1.0,
                progress_thresh = 50.0,
            )

            if ik_result.err_norm > 0.2:
                print(f"Finger {finger}: IK failed for intermediate position, err_norm={ik_result.err_norm}")
                break

            # Update joint positions
            current_qpos = np.zeros(len(self._finger_joints[finger]))
            for i, joint_name in enumerate(self._finger_joints[finger]):
                joint_idx = physics.model.name2id(joint_name, "joint")
                current_qpos[i] = ik_result.qpos[joint_idx]

            # Update fingertip position by setting the new joint positions and running forward kinematics
            original_qpos = physics.data.qpos.copy()
            for i, joint_name in enumerate(self._finger_joints[finger]):
                joint_idx = physics.model.name2id(joint_name, "joint")
                physics.data.qpos[joint_idx] = current_qpos[i]
            mujoco.mj_forward(physics.model.ptr, physics.data.ptr)
            current_fingertip_pos = physics.bind(fingertip_site).xpos.copy()
            physics.data.qpos[:] = original_qpos
            mujoco.mj_forward(physics.model.ptr, physics.data.ptr)
            # goal_qpos = np.zeros(len(self._finger_joints[finger]))
            # for i, joint_name in enumerate(self._finger_joints[finger]):
            #     joint_idx = physics.model.name2id(joint_name, "joint")
            #     goal_qpos[i] = ik_result.qpos[joint_idx]
        print(f"Finger {finger}: Projected joint positions: {current_qpos}")

        return current_qpos

    # def _plan_with_rrt(self, key: int, finger: int, physics) -> List[np.ndarray]:
    #     """Plan a path for the finger to reach the key using RRT in joint space."""
    #     # Get current joint configuration (start)
    #     start_qpos = np.zeros(len(self._finger_joints[finger]))
    #     for i, joint_name in enumerate(self._finger_joints[finger]):
    #         joint_idx = physics.model.name2id(joint_name, "joint")
    #         start_qpos[i] = physics.data.qpos[joint_idx]
    #     print(f"Finger {finger}: Starting joint positions: {start_qpos}")

    #     # Perturb initial joint positions to flex the finger downward
    #     original_qpos = physics.data.qpos.copy()
    #     for i, joint_name in enumerate(self._finger_joints[finger]):
    #         joint_idx = physics.model.name2id(joint_name, "joint")
    #         joint_range = physics.model.jnt_range[joint_idx]
    #         # Flex the joint to point downward (e.g., 50% of the range toward the upper limit)
    #         physics.data.qpos[joint_idx] = joint_range[0] + 0.5 * (joint_range[1] - joint_range[0])
    #     mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

    #     fingertip_site = self._hand.fingertip_sites[finger]
    #     fingertip_pos = physics.bind(fingertip_site).xpos.copy()
    #     fingertip_xmat = physics.bind(fingertip_site).xmat.reshape(3, 3)
    #     print(f"Finger {finger}: Perturbed fingertip position: {fingertip_pos}")

    #     # Reset joint positions
    #     physics.data.qpos[:] = original_qpos
    #     mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

    #     # Get target key position in world frame
    #     key_site = self.piano.keys[key].site[0]
    #     key_pos = physics.bind(key_site).xpos.copy()
    #     print(f"Key {key} position: {key_pos}")

    #     # Get key joint range to determine required press depth
    #     key_name = self.piano.keys[38].joint[0].name
    #     key_joint_id = physics.model.name2id(f"piano/{key_name}", "joint")
    #     key_range = physics.model.jnt_range[key_joint_id]
    #     print(f"Key {key} joint range: {key_range} (unpressed to fully pressed)")

    #     # Adjust key position for pressing
    #     press_pos = key_pos.copy()
    #     press_pos[-1] += key_range[1]  # Set to the fully pressed position
    #     print(f"Initial target press position: {press_pos}")

    #     # Convert press_pos to the fingertip's local frame
    #     relative_pos = press_pos - fingertip_pos
    #     fingertip_xmat_inv = np.linalg.inv(fingertip_xmat)
    #     local_press_pos = fingertip_xmat_inv @ relative_pos
    #     print(f"Finger {finger}: Target position in local frame (before fix): {local_press_pos}")

    #     # Fix: Ensure the z-component is negative (downward in the local frame)
    #     if local_press_pos[2] > 0:
    #         local_press_pos[2] = -local_press_pos[2]  # Flip the z-direction
    #     print(f"Finger {finger}: Target position in local frame (after fix): {local_press_pos}")

    #     # Compute goal joint configuration using IK with relaxed parameters
    #     site_name = self._hand.fingertip_sites[finger].name
    #     if self._hand_side == HandSide.LEFT:
    #         full_site_name = f"lh_shadow_hand/{site_name}"
    #     else:
    #         full_site_name = f"rh_shadow_hand/{site_name}"

    #     ik_result = qpos_from_site_pose(
    #         physics=physics,
    #         site_name=full_site_name,
    #         target_pos=local_press_pos,
    #         target_quat=None,
    #         joint_names=self._finger_joints[finger],
    #         tol=1e-1,
    #         max_steps=500,
    #         regularization_threshold=0.01,
    #         regularization_strength=0.1,
    #         max_update_norm=1.0,
    #         progress_thresh=50.0,
    #     )

    #     # Check IK result
    #     if ik_result.err_norm > 0.2:
    #         print(f"Finger {finger}: IK failed to converge, err_norm={ik_result.err_norm}")
    #         print(f"Finger {finger}: Falling back to projection toward goal position")
    #         goal_qpos = self._project_toward_goal(
    #             physics, finger, start_qpos, fingertip_pos, press_pos
    #         )
    #         if goal_qpos is None:
    #             print(f"Finger {finger}: Projection failed, returning empty trajectory")
    #             return []
    #     else:
    #         print(f"Finger {finger}: IK succeeded, err_norm={ik_result.err_norm}")
    #         goal_qpos = np.zeros(len(self._finger_joints[finger]))
    #         for i, joint_name in enumerate(self._finger_joints[finger]):
    #             joint_idx = physics.model.name2id(joint_name, "joint")
    #             goal_qpos[i] = ik_result.qpos[joint_idx]

    #     print(f"Finger {finger}: Goal joint positions: {goal_qpos}")

    #     # Joint limits
    #     joint_limits = np.zeros((len(self._finger_joints[finger]), 2))
    #     for i, joint_name in enumerate(self._finger_joints[finger]):
    #         joint_idx = physics.model.name2id(joint_name, "joint")
    #         joint_limits[i] = physics.model.jnt_range[joint_idx]
    #     print(f"Finger {finger}: Joint limits: {joint_limits}")

    #     # RRT parameters
    #     step_size = 0.05  # Smaller steps for better exploration
    #     max_iterations = 5000  # More iterations
    #     goal_bias = 0.3  # Higher chance of sampling the goal

    #     # Initialize the tree with the start configuration
    #     tree = [(start_qpos, None)]
    #     path_found = False

    #     for iteration in range(max_iterations):
    #         if np.random.random() < goal_bias:
    #             q_rand = goal_qpos
    #         else:
    #             q_rand = np.random.uniform(joint_limits[:, 0], joint_limits[:, 1])

    #         distances = [np.linalg.norm(q - q_rand) for q, _ in tree]
    #         nearest_idx = np.argmin(distances)
    #         q_near, _ = tree[nearest_idx]

    #         direction = q_rand - q_near
    #         distance = np.linalg.norm(direction)
    #         if distance < 1e-6:
    #             continue
    #         direction = direction / distance
    #         q_new = q_near + min(step_size, distance) * direction

    #         q_new = np.clip(q_new, joint_limits[:, 0], joint_limits[:, 1])

    #         if not self._check_collision(physics, finger, q_new):
    #             tree.append((q_new, nearest_idx))

    #             if np.linalg.norm(q_new - goal_qpos) < 2 * step_size:  # Relaxed criterion
    #                 print(f"Finger {finger}: RRT found a path after {iteration} iterations")
    #                 path_found = True
    #                 break
    #         else:
    #             print(f"Finger {finger}: Collision detected at iteration {iteration} for q_new={q_new}")

    #     if not path_found:
    #         print(f"Finger {finger}: RRT failed to find a path to the goal after {max_iterations} iterations")
    #         return []

    #     path = []
    #     current_idx = len(tree) - 1
    #     while current_idx is not None:
    #         q, parent_idx = tree[current_idx]
    #         path.append(q)
    #         current_idx = parent_idx
    #     path.reverse()

    #     smoothed_path = []
    #     num_steps = _NUM_STEPS_PER_SEGMENT * 3
    #     for i in range(len(path) - 1):
    #         q_start = path[i]
    #         q_end = path[i + 1]
    #         for t in np.linspace(0, 1, num_steps // (len(path) - 1)):
    #             q = q_start + t * (q_end - q_start)
    #             smoothed_path.append(q)

    #     return smoothed_path

    # def _project_toward_goal(
    #     self, physics, finger: int, start_qpos: np.ndarray, fingertip_pos: np.ndarray, target_pos: np.ndarray
    # ) -> Optional[np.ndarray]:
    #     """Project the fingertip toward the target position by moving joints incrementally."""
    #     current_qpos = start_qpos.copy()
    #     current_fingertip_pos = fingertip_pos.copy()
    #     max_projection_steps = 30  # Increased to get closer to the target
    #     step_size = 0.005  # 5 mm step

    #     for step in range(max_projection_steps):
    #         direction = target_pos - current_fingertip_pos
    #         distance = np.linalg.norm(direction)
    #         if distance < 1e-3:
    #             print(f"Finger {finger}: Fingertip reached target position after {step} steps")
    #             return current_qpos

    #         direction = direction / distance
    #         intermediate_pos = current_fingertip_pos + step_size * direction
    #         print(f"Finger {finger}: Projecting to intermediate position: {intermediate_pos}")

    #         fingertip_site = self._hand.fingertip_sites[finger]
    #         fingertip_xmat = physics.bind(fingertip_site).xmat.reshape(3, 3)
    #         fingertip_xmat_inv = np.linalg.inv(fingertip_xmat)
    #         local_intermediate_pos = fingertip_xmat_inv @ (intermediate_pos - current_fingertip_pos)

    #         # Fix: Ensure the z-component is negative
    #         if local_intermediate_pos[2] > 0:
    #             local_intermediate_pos[2] = -local_intermediate_pos[2]
    #         print(f"Finger {finger}: Intermediate position in local frame: {local_intermediate_pos}")

    #         site_name = self._hand.fingertip_sites[finger].name
    #         if self._hand_side == HandSide.LEFT:
    #             full_site_name = f"lh_shadow_hand/{site_name}"
    #         else:
    #             full_site_name = f"rh_shadow_hand/{site_name}"

    #         ik_result = qpos_from_site_pose(
    #             physics=physics,
    #             site_name=full_site_name,
    #             target_pos=local_intermediate_pos,
    #             target_quat=None,
    #             joint_names=self._finger_joints[finger],
    #             tol=1e-1,
    #             max_steps=1000,
    #             regularization_threshold=0.01,
    #             regularization_strength=0.1,
    #             max_update_norm=1.0,
    #             progress_thresh=50.0,
    #         )

    #         if ik_result.err_norm > 0.2:
    #             print(f"Finger {finger}: IK failed for intermediate position, err_norm={ik_result.err_norm}")
    #             break

    #         current_qpos = np.zeros(len(self._finger_joints[finger]))
    #         for i, joint_name in enumerate(self._finger_joints[finger]):
    #             joint_idx = physics.model.name2id(joint_name, "joint")
    #             current_qpos[i] = ik_result.qpos[joint_idx]

    #         original_qpos = physics.data.qpos.copy()
    #         for i, joint_name in enumerate(self._finger_joints[finger]):
    #             joint_idx = physics.model.name2id(joint_name, "joint")
    #             physics.data.qpos[joint_idx] = current_qpos[i]
    #         mujoco.mj_forward(physics.model.ptr, physics.data.ptr)
    #         current_fingertip_pos = physics.bind(fingertip_site).xpos.copy()
    #         physics.data.qpos[:] = original_qpos
    #         mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

    #     print(f"Finger {finger}: Projected joint positions: {current_qpos}")
    #     return current_qpos

    def _check_collision(self, physics, finger: int, qpos: np.ndarray) -> bool:
        """Check if the given joint configuration causes a collision."""
        original_qpos = physics.data.qpos.copy()
        for i, joint_name in enumerate(self._finger_joints[finger]):
            joint_idx = physics.model.name2id(joint_name, "joint")
            physics.data.qpos[joint_idx] = qpos[i]

        mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

        fingertip_site = self._hand.fingertip_sites[finger]
        fingertip_body = fingertip_site.parent
        fingertip_body_id = physics.model.name2id(f"rh_shadow_hand/{fingertip_body.name}", "body")

        collision_detected = False
        for i in range(physics.data.ncon):
            contact = physics.data.contact[i]
            body1 = physics.model.geom_bodyid[contact.geom1]
            body2 = physics.model.geom_bodyid[contact.geom2]
            if body1 == fingertip_body_id or body2 == fingertip_body_id:
                if "key" not in physics.model.id2name(contact.geom1, "geom") and \
                   "key" not in physics.model.id2name(contact.geom2, "geom"):
                    collision_detected = True
                    break

        physics.data.qpos[:] = original_qpos
        mujoco.mj_forward(physics.model.ptr, physics.data.ptr)

        return collision_detected

    def _compute_dynamics(self, physics):
        """Compute the mass matrix, Coriolis/centrifugal forces, and gravity terms."""
        qpos = physics.data.qpos.copy()
        qvel = physics.data.qvel.copy()
        
        nv = physics.model.nv
        mass_matrix = np.zeros((nv, nv), dtype=np.float64, order='C')
        mujoco.mj_step1(physics.model.ptr, physics.data.ptr)
        mujoco.mj_fullM(physics.model.ptr, mass_matrix, physics.data.qM)
        
        coriolis_and_gravity = physics.data.qfrc_bias.copy()
        coriolis = coriolis_and_gravity
        gravity = coriolis_and_gravity
        
        return mass_matrix, coriolis, gravity

    def _compute_action(self, physics, qpos_desired, qvel_desired, qacc_desired):
        """Compute joint torques using feedforward-feedback control."""
        qpos = physics.data.qpos.copy()
        qvel = physics.data.qvel.copy()

        M, C, G = self._compute_dynamics(physics)

        e = qpos_desired - qpos
        e_dot = qvel_desired - qvel

        feedback = _KP * e + _KD * e_dot
        tau = M @ (qacc_desired + feedback) + C + G

        return tau

    def _update_hand_position(self, physics):
        """Generate and execute trajectories for each finger using RRT."""
        print(f"Updating hand position at timestep {self._t_idx}")
        print(f"Current keys to play: {self._keys_current}")

        # Generate new trajectories for active fingers
        for key, mjcf_fingering in self._keys_current:
            if not self._trajectories[mjcf_fingering]:
                print(f"Planning trajectory for finger {mjcf_fingering} to key {key}")
                traj = self._plan_with_rrt(key, mjcf_fingering, physics)
                self._trajectories[mjcf_fingering] = traj
                self._traj_steps[mjcf_fingering] = 0
                print(f"Trajectory length for finger {mjcf_fingering}: {len(traj)}")
        
        # Execution of trajectories (directly use joint configurations)
        qpos_desired = physics.data.qpos.copy()
        qvel_desired = physics.data.qvel.copy()
        qacc_desired = np.zeros_like(qpos_desired)

        for finger in range(5):
            if self._trajectories[finger]:
                step = self._traj_steps[finger]
                if step < len(self._trajectories[finger]):
                    qpos_finger = self._trajectories[finger][step]

                    for i, joint_name in enumerate(self._finger_joints[finger]):
                        joint_idx = physics.model.name2id(joint_name, "joint")
                        qpos_desired[joint_idx] = qpos_finger[i]
                        joint_range = physics.model.jnt_range[joint_idx]
                        qpos_desired[joint_idx] = np.clip(qpos_desired[joint_idx], joint_range[0], joint_range[1])
                        if self._last_qpos is not None:
                            qvel_desired[joint_idx] = (qpos_desired[joint_idx] - self._last_qpos[joint_idx]) / self.control_timestep
                            if self._last_qvel is not None:
                                qacc_desired[joint_idx] = (qvel_desired[joint_idx] - self._last_qvel[joint_idx]) / self.control_timestep
                    self._traj_steps[finger] += 1

                    # Debug: Check fingertip position, key position, and key state
                    site_name = self._hand.fingertip_sites[finger].name
                    if self._hand_side == HandSide.LEFT:
                        full_site_name = f"lh_shadow_hand/{site_name}"
                    else:
                        full_site_name = f"rh_shadow_hand/{site_name}"

                    fingertip_pos = physics.named.data.site_xpos[full_site_name]
                    for key, mjcf_fingering in self._keys_current:
                        if mjcf_fingering == finger:
                            key_site = self.piano.keys[key].site[0]
                            key_pos = physics.bind(key_site).xpos.copy()
                            distance = np.linalg.norm(fingertip_pos - key_pos)
                            key_activation = self.piano.activation[key]
                            key_state = self.piano.state[key]
                            print(f"Finger {finger}, Step {step}: Fingertip pos: {fingertip_pos}, Key pos: {key_pos}")
                            print(f"Finger {finger}, Step {step}: Distance to key {key}: {distance:.4f} m, Key state: {key_state:.4f}, Key activation: {key_activation}")
                else:
                    self._trajectories[finger] = []
                    self._traj_steps[finger] = 0
                    print(f"Finger {finger}: Trajectory completed")
        
        action = self._compute_action(physics, qpos_desired, qvel_desired, qacc_desired)

        self._last_qpos = qpos_desired.copy()
        self._last_qvel = qvel_desired.copy()

        return action

    def initialize_episode(self, physics, random_state) -> None:
        print("Initializing episode...")
        self._maybe_change_midi(random_state)
        self._reset_quantities_at_episode_init()

    def after_step(self, physics, random_state) -> None:
        print(f"After step {self._t_idx}")
        self._t_idx += 1
        self._should_terminate = (self._t_idx - 1) == len(self._notes) - 1

        self._update_goal_state()
        self._goal_current = self._goal_state[0]
        print(f"Goal state: {self._goal_current}")
        print(f"Non-zero indices in goal state: {np.flatnonzero(self._goal_current)}")

        if not self._disable_fingering_reward:
            self._update_fingering_state()
            self._keys_current = self._keys
            if not self._disable_colorization:
                self._colorize_keys(physics)

        # Then, update the goal state based on the assigned keys
        self._update_goal_state()
        self._goal_current = self._goal_state[0]
        print(f"Goal state: {self._goal_current}")
        print(f"Non-zero indices in goal state: {np.flatnonzero(self._goal_current)}")

        should_not_be_pressed = np.flatnonzero(1 - self._goal_current[:-1])
        self._failure_termination = self.piano.activation[should_not_be_pressed].any()

        action = self._update_hand_position(physics)

        joints = self._hand.actuators
        QPOS_INDS = []
        for joint in joints:
            if joint.joint:   
                QPOS_INDS.append(physics.model.joint("rh_shadow_hand/" + joint.joint.name).id)
            elif joint.tendon:
                QPOS_INDS.append(physics.model.tendon("rh_shadow_hand/" + joint.tendon.name).id)
            else:
                raise ValueError(f"Joint or tendon not found for {joint.name}")
        
        action = action[QPOS_INDS]
        
        self._hand.apply_action(physics, action, random_state)

        sustain = self._goal_current[-1]
        self.piano.apply_sustain(physics, sustain, random_state)

    def get_reward(self, physics) -> float:
        return self._reward_fn.compute(physics)

    def get_discount(self, physics) -> float:
        del physics
        return self._discount

    def should_terminate_episode(self, physics) -> bool:
        del physics
        if self._should_terminate:
            return True
        if self._wrong_press_termination and self._failure_termination:
            self._discount = 0.0
            return True
        return False

    @property
    def midi(self) -> midi_file.MidiFile:
        return self._midi

    @property
    def reward_fn(self) -> composite_reward.CompositeReward:
        return self._reward_fn

    @property
    def task_observables(self):
        return self._task_observables

    def action_spec(self, physics):
        hand_spec = self._hand.action_spec(physics)
        sustain_spec = specs.BoundedArray(
            shape=(1,),
            dtype=hand_spec.dtype,
            minimum=[0.0],
            maximum=[1.0],
            name="sustain",
        )
        return spec_utils.merge_specs([hand_spec, sustain_spec])

    def before_step(self, physics, action, random_state) -> None:
        pass

    def _compute_sustain_reward(self, physics) -> float:
        del physics
        return tolerance(
            self._goal_current[-1] - self.piano.sustain_activation[0],
            bounds=(0, _KEY_CLOSE_ENOUGH_TO_PRESSED),
            margin=(_KEY_CLOSE_ENOUGH_TO_PRESSED * 10),
            sigmoid="gaussian",
        )

    def _compute_energy_reward(self, physics) -> float:
        power = self._hand.observables.actuators_power(physics).copy()
        return -_ENERGY_PENALTY_COEF * np.sum(power)

    def _compute_key_press_reward(self, physics) -> float:
        del physics
        on = np.flatnonzero(self._goal_current[:-1])
        rew = 0.0
        if on.size > 0:
            actual = np.array(self.piano.state / self.piano._qpos_range[:, 1])
            rews = tolerance(
                self._goal_current[:-1][on] - actual[on],
                bounds=(0, _KEY_CLOSE_ENOUGH_TO_PRESSED),
                margin=(_KEY_CLOSE_ENOUGH_TO_PRESSED * 10),
                sigmoid="gaussian",
            )
            rew += 0.5 * rews.mean()
        off = np.flatnonzero(1 - self._goal_current[:-1])
        rew += 0.5 * (1 - float(self.piano.activation[off].any()))
        return rew

    def _compute_fingering_reward(self, physics) -> float:
        def _distance_finger_to_key(
            hand_keys: List[Tuple[int, int]], hand
        ) -> List[float]:
            distances = []
            for key, mjcf_fingering in hand_keys:
                fingertip_site = hand.fingertip_sites[mjcf_fingering]
                fingertip_pos = physics.bind(fingertip_site).xpos.copy()
                key_geom = self.piano.keys[key].geom[0]
                key_geom_pos = physics.bind(key_geom).xpos.copy()
                key_geom_pos[-1] += 0.5 * physics.bind(key_geom).size[2]
                key_geom_pos[0] += 0.35 * physics.bind(key_geom).size[0]
                diff = key_geom_pos - fingertip_pos
                distances.append(float(np.linalg.norm(diff)))
            return distances

        distances = _distance_finger_to_key(self._keys_current, self._hand)

        if not distances:
            return 0.0

        rews = tolerance(
            np.hstack(distances),
            bounds=(0, _FINGER_CLOSE_ENOUGH_TO_KEY),
            margin=(_KEY_CLOSE_ENOUGH_TO_PRESSED * 10),
            sigmoid="gaussian",
        )
        return float(np.mean(rews))

    def _update_goal_state(self) -> None:
        if self._t_idx == len(self._notes):
            print(f"Timestep {self._t_idx}: Reached end of notes")
            return

        print(f"Updating goal state for timestep {self._t_idx}, lookahead {self._n_steps_lookahead}")
        self._goal_state = np.zeros(
            (self._n_steps_lookahead + 1, self.piano.n_keys + 1),
            dtype=np.float64,
        )
        t_start = self._t_idx
        t_end = min(t_start + self._n_steps_lookahead + 1, len(self._notes))
        print(f"Processing timesteps {t_start} to {t_end-1}")
        for i, t in enumerate(range(t_start, t_end)):
            keys = [note.key for note in self._notes[t]]
            print(f"Timestep {t}: Notes: {self._notes[t]}, Keys to play: {keys}")

            if not keys and t == self._t_idx and hasattr(self, "_keys"):
                keys = [key for key, _ in self._keys]
                print(f"Timestep {t}: Using keys from self._keys: {keys}")

            if keys:
                self._goal_state[i, keys] = 1.0
            self._goal_state[i, -1] = self._sustains[t]
        print(f"Goal state shape: {self._goal_state.shape}")
        print(f"Non-zero indices in goal state[0]: {np.flatnonzero(self._goal_state[0])}")

    def _update_fingering_state(self) -> None:
        if self._t_idx == len(self._notes):
            print(f"Timestep {self._t_idx}: Reached end of notes")
            return

        fingering = [note.fingering for note in self._notes[self._t_idx]]
        fingering_keys = [note.key for note in self._notes[self._t_idx]]
        print(f"Timestep {self._t_idx}: Notes to play: {self._notes[self._t_idx]}")
        print(f"Timestep {self._t_idx}: Fingering: {fingering}, Keys: {fingering_keys}")

        self._keys: List[Tuple[int, int]] = []
        buffer_steps = int(self._initial_buffer_time / self.control_timestep)
        if not fingering and self._t_idx == buffer_steps:
            self._keys.append((48, 0))  # Key 48 (middle C) with thumb
            print("Hardcoding key 48 for finger 0")
        else:
            for key, finger in enumerate(fingering):
                piano_key = fingering_keys[key]
                if finger < 5:
                    if self._hand_side == HandSide.RIGHT:
                        self._keys.append((piano_key, finger))
                else:
                    if self._hand_side == HandSide.LEFT:
                        self._keys.append((piano_key, finger - 5))

        self._fingering_state = np.zeros((5,), dtype=np.float64)
        for _, mjcf_fingering in self._keys:
            self._fingering_state[mjcf_fingering] = 1.0
        print(f"Timestep {self._t_idx}: Keys assigned: {self._keys}")
        print(f"Timestep {self._t_idx}: Fingering state: {self._fingering_state}")

    def _add_observables(self) -> None:
        enabled_observables = [
            "joints_pos",
            "position",
        ]
        for obs in enabled_observables:
            getattr(self._hand.observables, obs).enabled = True

        self.piano.observables.state.enabled = True
        self.piano.observables.sustain_state.enabled = True
        self.piano.observables.activation.enabled = False
        self.piano.observables.sustain_activation.enabled = False

        def _get_goal_state(physics) -> np.ndarray:
            del physics
            self._update_goal_state()
            return self._goal_state.ravel()

        goal_observable = observable.Generic(_get_goal_state)
        goal_observable.enabled = True
        self._task_observables = {"goal": goal_observable}

        def _get_fingering_state(physics) -> np.ndarray:
            del physics
            self._update_fingering_state()
            return self._fingering_state.ravel()

        fingering_observable = observable.Generic(_get_fingering_state)
        fingering_observable.enabled = not self._disable_fingering_reward
        self._task_observables["fingering"] = fingering_observable

        def _get_steps_left(physics) -> float:
            del physics
            return (len(self._notes) - self._t_idx) / len(self._notes)

        steps_left_observable = observable.Generic(_get_steps_left)
        steps_left_observable.enabled = False
        self._task_observables["steps_left"] = steps_left_observable

    def _colorize_fingertips(self) -> None:
        for i, name in enumerate(hand_consts.FINGERTIP_BODIES):
            color = hand_consts.FINGERTIP_COLORS[i] + (0.5,)
            body = self._hand.mjcf_model.find("body", name)
            for geom in body.find_all("geom"):
                if geom.dclass.dclass == "plastic_visual":
                    geom.rgba = color
            self._hand.fingertip_sites[i].rgba = color

    def _colorize_keys(self, physics) -> None:
        for key, mjcf_fingering in self._keys_current:
            key_geom = self.piano.keys[key].geom[0]
            fingertip_site = self._hand.fingertip_sites[mjcf_fingering]
            if not self.piano.activation[key]:
                physics.bind(key_geom).rgba = tuple(fingertip_site.rgba[:3]) + (1.0,)